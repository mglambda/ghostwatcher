# types.py
# types for the ghostwatcher project

from typing import *
from pydantic import BaseModel, Field
from enum import StrEnum

class ExtractionStrategy(StrEnum):
    keyframes = "keyframes"
    interval = "interval"

class ImageExtractorConfig(BaseModel):
    """Config object containing parameters for various extraction functions.
    Not all of the options may be used by all of the functions"""

    use_keyframes: bool = Field(
        default = True,
        description = "Use keyframes or iframes if available in the video."
    )

    min_interval: Optional[float] = Field(
        default = None,
        description = "Minimum interval in seconds between images."
    )

    max_interval: Optional[float] = Field(
        default = None,
        description = "Maximum interval in seconds between images."
    )

    # more options to come in the future
    
class ImageExtractor(Protocol):
    """Interface for video image extractor functions."""

    def process(self, video_filepath: str, output_directory_filepath: str, config: ImageExtractorConfig) -> None:
        pass



class FrameImage(BaseModel):
    """Small wrapper to represent a single video frame, with possible metadata and descriptions."""

    filepath: str = Field(
        description = "The filepath to this frame's image file."
    )

    seek_pos: float = Field(
        default = -1.0,
        description = "The time position in seconds at which this frame occurs in the video. Negative values indicate that the position could not be determined."
    )
    
    description: Optional[str] = Field(
        default = None,
        description = "An image description generated by a multimodal AI. May built upon descriptions of preceding images."
    )

class FrameCollection(BaseModel):
    """An ordered collection of image frames, with possible descriptions and metadata."""
    video_filepath: str = Field(
        description = "Filepath to the video that the frames belong to. Mostly for logging and documentation purposes."
    )
    
    frames: List[FrameImage] = Field(
        default_factory = list,
        description = "The frames, in chronological order, that were extracted from the video."
    )

    @staticmethod
    def from_directory(extraction_output_dir: str, video_filepath: str) -> 'FrameCollection':
        """Create a new framecollection with empty metadata by loading all images from a directory in alphabetical order."""
        from pathlib import Path
        import re

        output_path = Path(extraction_output_dir)
        image_files = []
        for f in output_path.iterdir():
            if f.is_file() and f.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                image_files.append(f)

        # Sort files alphabetically to maintain chronological order
        image_files.sort()

        frames = []
        for img_file in image_files:
            seek_pos = -1.0
            # Try to extract timestamp from filename (e.g., frame-0001-ts-12.345.png)
            ts_match = re.search(r"-ts-([\d\.]+)", img_file.stem)
            if ts_match:
                try:
                    seek_pos = float(ts_match.group(1))
                except ValueError:
                    pass
            
            frames.append(FrameImage(
                filepath=str(img_file),
                seek_pos=seek_pos
            ))

        return FrameCollection(
            video_filepath=video_filepath,
            frames=frames
        )

class LLMConfig(BaseModel):
    """Configuration parameters for the image description generation that are used with the LLM backend."""

    batch_size: int = Field(
        default = 3,
        description = "How many images to describe in one batch. A higher batch size gives better results because the LLM will have more images in context simultaneously, but also requires substantially more memory and processing time."
    )
    
    description_prompt: str = Field(
        default = "Describe the image.",
        description = "Prompt used for basic image descriptions."
    )

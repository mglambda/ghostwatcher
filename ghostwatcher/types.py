# types.py
# types for the ghostwatcher project

from typing import *
import re
import json
from pydantic import BaseModel, Field
from enum import StrEnum
from pathlib import Path
from ghostbox import Ghostbox


class ExtractionStrategy(StrEnum):
    keyframes = "keyframes"
    interval = "interval"


class ImageExtractorConfig(BaseModel):
    """Config object containing parameters for various extraction functions.
    Not all of the options may be used by all of the functions"""

    use_keyframes: bool = Field(
        default=True, description="Use keyframes or iframes if available in the video."
    )

    min_interval: Optional[float] = Field(
        default=None, description="Minimum interval in seconds between images."
    )

    max_interval: Optional[float] = Field(
        default=None, description="Maximum interval in seconds between images."
    )

    # more options to come in the future


class ImageExtractor(Protocol):
    """Interface for video image extractor functions."""

    def process(
        self,
        video_filepath: str,
        output_path: Path,
        config: ImageExtractorConfig,
    ) -> None:
        pass


class FrameImage(BaseModel):
    """Small wrapper to represent a single video frame, with possible metadata and descriptions."""

    filepath: str = Field(description="The filepath to this frame's image file.")

    seek_pos: float = Field(
        default=-1.0,
        description="The time position in seconds at which this frame occurs in the video. Negative values indicate that the position could not be determined.",
    )

    description: Optional[str] = Field(
        default=None,
        description="An image description generated by a multimodal AI. May built upon descriptions of preceding images.",
    )


class FrameCollection(BaseModel):
    """An ordered collection of image frames, with possible descriptions and metadata."""

    video_filepath: str = Field(
        description="Filepath to the video that the frames belong to. Mostly for logging and documentation purposes."
    )

    frames: List[FrameImage] = Field(
        default_factory=list,
        description="The frames, in chronological order, that were extracted from the video.",
    )

    @staticmethod
    def from_directory(output_path: Path, video_filepath: str) -> "FrameCollection":
        """Create a new framecollection with empty metadata by loading all images from a directory in alphabetical order."""

        image_files = []
        for f in output_path.iterdir():
            if f.is_file() and f.suffix.lower() in [".png", ".jpg", ".jpeg"]:
                image_files.append(f)

        # Sort files alphabetically to maintain chronological order
        image_files.sort()

        frames = []
        for img_file in image_files:
            seek_pos = -1.0
            # Try to extract timestamp from filename (e.g., frame-0001-ts-12.345.png)
            ts_match = re.search(r"-ts-([\d\.]+)", img_file.stem)
            if ts_match:
                try:
                    seek_pos = float(ts_match.group(1))
                except ValueError:
                    pass

            frames.append(FrameImage(filepath=str(img_file), seek_pos=seek_pos))

        return FrameCollection(video_filepath=video_filepath, frames=frames)

    def save(self, filepath: Path) -> None:
        """Save the frame collection to a JSON file."""
        filepath.write_text(self.model_dump_json(indent=2))

    @staticmethod
    def load(filepath: Path) -> "FrameCollection":
        """Load a frame collection from a JSON file."""
        return FrameCollection.model_validate_json(filepath.read_text())

class LLMConfig(BaseModel):
    """Configuration parameters for the image description generation that are used with the LLM backend."""

    batch_size: int = Field(
        default=3,
        description="How many images to describe in one batch. A higher batch size gives better results because the LLM will have more images in context simultaneously, but also requires substantially more memory and processing time.",
    )

    batch_description_prompt_part: str = Field(
        default="Here are several still frames from a video. All but the last one have been previously described. Focus on the last image, do not repeat describing the first few images, but do include contextual knowledge of them   in your description, and describe any changes that have taken place in the newest image compared to the previous ones.",
        description="Text snippet included in the image description prompt if the batch size is greater than 1.",
    )

    description_prompt: str = Field(
        default="Describe the image.",
        description="Prompt used for basic image descriptions.",
    )


class Program(BaseModel):
    """Holds context relevant for program execution."""

    output_dir: Path = Field(
        description="Directory where the final output will be stored."
    )

    work_dir: Path = Field(
        description="Directory where intermediate results and other temporary files will be stored. The directory may be temporary."
    )

    box: Ghostbox = Field(description="Ghostbox instance.")

    def get_extraction_output_dir(self) -> Path:
        """Returns the path to the directory that should contain extracted frames. Ensures the directory exists."""
        extraction_output_dir = self.work_dir / "extracted_frames"
        extraction_output_dir.mkdir(parents=True, exist_ok=True)
        return extraction_output_dir


    def get_frame_collection_path(self) -> Path:
        """Returns the path to the file that contains the program's frame collection.
        This can be used to store intermediate results and to restore previous runs of the program."""
        return self.work_dir / "frame_collection.json"
